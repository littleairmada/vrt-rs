extern crate nom;
extern crate vrt;

#[cfg(test)]
mod tests {
    use crate::vrt::*;

    static VRT_FLEXRADIO_BROADCAST_MSG: &[u8] = &[
        0x38, 0x5f, 0x00, 0x8a, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1c, 0x2d, 0x53, 0x4c, 0xff,
        0xff, 0x62, 0x43, 0x8f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x69,
        0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
        0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x33, 0x2e, 0x30, 0x2e, 0x30,
        0x2e, 0x31, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x3d, 0x46, 0x4c, 0x45, 0x58, 0x2d, 0x36,
        0x37, 0x30, 0x30, 0x20, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x3d, 0x31, 0x31, 0x32, 0x31,
        0x2d, 0x31, 0x31, 0x30, 0x34, 0x2d, 0x36, 0x37, 0x30, 0x30, 0x2d, 0x32, 0x39, 0x31, 0x32,
        0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x33, 0x2e, 0x32, 0x2e, 0x33, 0x39,
        0x2e, 0x33, 0x33, 0x37, 0x34, 0x20, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x3d,
        0x50, 0x53, 0x4f, 0x43, 0x32, 0x2f, 0x48, 0x46, 0x2f, 0x41, 0x4d, 0x50, 0x20, 0x63, 0x61,
        0x6c, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x3d, 0x57, 0x34, 0x42, 0x52, 0x20, 0x69, 0x70, 0x3d,
        0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x30, 0x2e, 0x31, 0x31, 0x20, 0x70, 0x6f,
        0x72, 0x74, 0x3d, 0x34, 0x39, 0x39, 0x32, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3d,
        0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x75, 0x73, 0x65,
        0x5f, 0x69, 0x70, 0x3d, 0x20, 0x69, 0x6e, 0x75, 0x73, 0x65, 0x5f, 0x68, 0x6f, 0x73, 0x74,
        0x3d, 0x20, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x64, 0x5f,
        0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x76, 0x33, 0x20, 0x72, 0x61, 0x64, 0x69,
        0x6f, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x5f, 0x69, 0x64, 0x3d, 0x30, 0x30,
        0x2d, 0x31, 0x43, 0x2d, 0x32, 0x44, 0x2d, 0x30, 0x32, 0x2d, 0x30, 0x46, 0x2d, 0x45, 0x41,
        0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61, 0x64, 0x64, 0x69, 0x74,
        0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x3d, 0x30,
        0x20, 0x66, 0x70, 0x63, 0x5f, 0x6d, 0x61, 0x63, 0x3d, 0x20, 0x77, 0x61, 0x6e, 0x5f, 0x63,
        0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x3d, 0x31, 0x20, 0x6c, 0x69, 0x63, 0x65,
        0x6e, 0x73, 0x65, 0x64, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x3d, 0x32, 0x20,
        0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e,
        0x74, 0x73, 0x3d, 0x32, 0x20, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x61, 0x6e, 0x61, 0x64, 0x61,
        0x70, 0x74, 0x65, 0x72, 0x73, 0x3d, 0x38, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62,
        0x6c, 0x65, 0x5f, 0x70, 0x61, 0x6e, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x3d,
        0x38, 0x20, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x73, 0x3d, 0x38, 0x20,
        0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65,
        0x73, 0x3d, 0x38, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f,
        0x69, 0x70, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
        0x5f, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69,
        0x65, 0x6e, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x73, 0x3d, 0x20, 0x67,
        0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
        0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x73, 0x3d, 0x00, 0x00, 0x00,
    ];

    static VRT_STATIC_TRAILER_TEST_PATTERN: &[u8] = &[0xAA, 0xAA, 0xAA, 0xAA];

    #[test]
    fn test_parse_vrt_header() {
        let bytes = &VRT_FLEXRADIO_BROADCAST_MSG[0..4];
        let expected = Header {
            packet_type: VitaPacketType(3),
            c: true,
            t: false,
            tsi: Tsi(1),
            tsf: Tsf(1),
            packet_count: 15,
            packet_size: 138,
        };
        let (_, res) = parse_vrt_header(bytes).expect("failed to parse header");
        assert_eq!(res, expected);
    }

    #[test]
    fn test_parse_vrt_header_tooshort() {
        let bytes = &VRT_FLEXRADIO_BROADCAST_MSG[0..2];
        let actual_error_bool = parse_vrt_header(bytes).unwrap_err().is_incomplete();
        let expected_error_bool = true;
        assert_eq!(actual_error_bool, expected_error_bool);
    }

    #[test]
    fn test_parse_vrt_trailer() {
        let bytes = &VRT_STATIC_TRAILER_TEST_PATTERN[0..4];
        let expected: Trailer = Trailer {
            calibrated_time_enable: true,
            valid_data_enable: false,
            reference_lock_enable: true,
            agcmgc_enable: false,
            detected_signal_enable: true,
            spectral_inversion_enable: false,
            overrange_enable: true,
            sample_loss_enable: false,
            user_defined_enable_1: true,
            user_defined_enable_2: false,
            user_defined_enable_3: true,
            user_defined_enable_4: false,
            calibrated_time_indicator: true,
            valid_data_indicator: false,
            reference_lock_indicator: true,
            agcmgc_indicator: false,
            detected_signal_indicator: true,
            spectral_inversion_indicator: false,
            overrange_indicator: true,
            sample_loss_indicator: false,
            user_defined_indicator_1: true,
            user_defined_indicator_2: false,
            user_defined_indicator_3: true,
            user_defined_indicator_4: false,
            associated_context_packet_count_enable: true,
            associated_context_packet_count: 42,
        };
        let (_, res) = parse_vrt_trailer(bytes).expect("failed to parse trailer");
        assert_eq!(res, expected);
    }

    #[test]
    fn test_parse_vrt_trailer_tooshort() {
        let bytes = &VRT_STATIC_TRAILER_TEST_PATTERN[0..2];
        let actual_error_bool = parse_vrt_trailer(bytes).unwrap_err().is_incomplete();
        let expected_error_bool = true;
        assert_eq!(actual_error_bool, expected_error_bool);
    }

    #[test]
    fn test_parse_vrt_packet() {
        let bytes = VRT_FLEXRADIO_BROADCAST_MSG;
        let (_, res) = parse_vrt_packet(bytes).expect("failed to parse packet");
        assert_eq!(res.stream_id, Some(2048));
        const FLEX_RADIO_OUI: u32 = 0x001C2D;
        let oui = res.class_id.map(|v| ((v >> 32) & 0xFFFFFF) as u32);
        assert_eq!(oui, Some(FLEX_RADIO_OUI));
        assert_eq!(res.data_payload, b"discovery_protocol_version=3.0.0.1 model=FLEX-6700 serial=1121-1104-6700-2912 version=3.2.39.3374 nickname=PSOC2/HF/AMP callsign=W4BR ip=192.168.0.11 port=4992 status=Available inuse_ip= inuse_host= max_licensed_version=v3 radio_license_id=00-1C-2D-02-0F-EA requires_additional_license=0 fpc_mac= wan_connected=1 licensed_clients=2 available_clients=2 max_panadapters=8 available_panadapters=8 max_slices=8 available_slices=8 gui_client_ips= gui_client_hosts= gui_client_programs= gui_client_stations= gui_client_handles=\0\0\0");
    }
}
